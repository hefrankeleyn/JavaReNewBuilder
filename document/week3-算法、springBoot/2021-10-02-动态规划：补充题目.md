# 动态规划：补充题目

[toc]

## 一、[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### 1.1 动态规划

```
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        // dp[i] 第i个元素的自增子序列个数等于 （num[i]>num[j]）是 dp[j] + 1
        dp[0] = 1;
        int res = dp[0];
        for (int i=1; i<n; i++) {
            dp[i] = 1;
            for (int j=0; j<i; j++) {
                if (nums[i]>nums[j]) {
                    dp[i] = Math.max(dp[j]+1, dp[i]);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```

## 二、[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

### 2.1 解法一：动态规划，类似于爬楼梯

```
    public int numDecodings(String s) {
        int n = s.length();
        if (s.charAt(0)=='0') return 0;
        // 类似于爬楼梯
        int[] dp = new int[n];
        dp[0]=1;
        for (int i=1; i<n; i++) {
            if (dp[i-1]==0) return 0;
            int v1 = Integer.parseInt(s.substring(i,i+1));
            int t = 0;
            if (v1<=26 && v1>0) t=dp[i-1];
            if (s.charAt(i-1)!='0') {
                int v2 = Integer.parseInt(s.substring(i-1,i+1));
                if (v2>0 && v2<=26) {
                    if (i>1) t+=dp[i-2];
                    else t=t+1;
                }
            }
            dp[i] = t;
        }
        return dp[n-1];
    }
```

### 2.2 解法二：动态规划：空间优化

```
    public int numDecodings(String s) {
        int n = s.length();
        if (s.charAt(0)=='0') return 0;
        if (n==1) return 1;
        int pre = 1;
        int cur = 0;
        if (s.charAt(1)!='0') {
            cur = 1;
        }
        int tv1 = Integer.parseInt(s.substring(0, 2));
        if (tv1>0 && tv1<=26) {
            cur = cur+1;
        }
        for (int i=2; i<n; i++) {
            if (cur==0) return 0;
            int tv = 0;
            if (s.charAt(i)!='0') tv=cur;
            if (s.charAt(i-1)!='0') {
                int tv2 = Integer.parseInt(s.substring(i-1, i+1));
                if (tv2>0 && tv2<=26) {
                    tv += pre;
                }
            }
            pre = cur;
            cur = tv;
        }
        return cur;
    }
```

## 三、[32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

### 3.1 动态规划

两种情况：`...()` 或`(...)` , 其中`...` 是有效括号。

```
    public int longestValidParentheses(String s) {
        int n = s.length();
        if (n<2) return 0;
        int[] dp = new int[n];
        int res = 0;
        for (int i=1; i<n; i++) {
            if (s.charAt(i)==')') {
                if (s.charAt(i-1)=='(') {
                    dp[i] = i-2>=0?dp[i-2]+2:2;
                }else if (dp[i-1]>0 && i-dp[i-1]-1>=0 && s.charAt(i-dp[i-1]-1)=='('){
                    dp[i] = dp[i-1]+(i-dp[i-1]-2>=0?dp[i-dp[i-1]-2]:0)+2;
                }
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
```




#  字典树及经典题目

[toc]

## 一、字典树Trie

（空间换时间）

- 优点：最大限度的减少无谓的字符串比较，查询效率比哈希表高；
- 使用场景：统计和排序大量的字符串。经常被搜索引擎用于文本词频统计；
- 特性：
  - 节点不存完整单词；
  - 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串；
  - 不同路径代表的字符串都不相同；
  - 节点上添加数值，可以代表统计频次，对用户进行推荐；

## 二、经典题目

### 2.1 [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

Java实现：

```java
class Trie {

    private Trie[] t;
    private static final int R = 26;
    private boolean end;
    public Trie() {
        t = new Trie[R];
    }
    public void insert(String word) {
        Trie x = this;
        for (int i=0; i<word.length(); i++) {
            if (!x.containsTrie(word.charAt(i))) {
                x.putNode(word.charAt(i), new Trie());
            }
            x = x.getNode(word.charAt(i));
        }
        x.setEnd();
    }
    
    public boolean search(String word) {
        Trie p = searchPrefix(word);
        return p!=null && p.isEnd();
    }
    
    public boolean startsWith(String prefix) {
        Trie p = searchPrefix(prefix);
        return p!=null;
    }

    private Trie searchPrefix(String prefix) {
        Trie x = this;
        for (int i=0; i<prefix.length(); i++) {
            if (x.containsTrie(prefix.charAt(i))) {
                x = x.getNode(prefix.charAt(i));
            }else {
                return null;
            }
        }
        return x;
    }

    private boolean containsTrie(char c) {
        return getNode(c)!=null;
    }

    private Trie getNode(char c) {
        return t[c-'a'];
    }

    private void putNode(char c, Trie trie) {
        t[c-'a'] = trie;
    }

    private boolean isEnd() {
        return end;
    }

    private void setEnd() {
        this.end = true;
    }
}
```

python的实现

```python
class Trie:

    def __init__(self):
        self.root = {}
        self.end_of_word = '#'


    def insert(self, word: str) -> None:
        m = self.root
        for w in word:
            m = m.setdefault(w, {})
        m[self.end_of_word] = {}


    def search(self, word: str) -> bool:
        m = self.root
        for w in word:
            if w in m:
                m = m[w]
            else:
                return False
        return self.end_of_word in m


    def startsWith(self, prefix: str) -> bool:
        m = self.root
        for w in prefix:
            if w in m:
                m = m[w]
            else:
                return False
        return True
```


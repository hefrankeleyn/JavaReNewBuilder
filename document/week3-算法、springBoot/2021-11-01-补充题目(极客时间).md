#  极客时间的补充算法题目

[toc]

## 一、[1. 选择餐馆](https://u.geekbang.org/playground/exam/1020?question=8571)

### 解法一：获取值，并排序

```java
    public int[] filterRestaurants(int[][] restaurants, int[] filters) {
      List<Pair> res = new ArrayList<>();
      int k=0;
      for (int i=0; i<restaurants.length; i++) {
        if (restaurants[i][3]<=filters[1] && restaurants[i][4]<=filters[2]) {
          if ((filters[0]==1 && restaurants[i][2]==1) || filters[0]==0) {
            res.add(new Pair(restaurants[i][0], restaurants[i][1]));
          }
        }
      }
      Collections.sort(res, (o1,o2)->{return o2.rating-o1.rating!=0?o2.rating-o1.rating:o2.id-o1.id;});
      int[] a = new int[res.size()];
      for (int i=0;i<res.size(); i++) {
        a[i] = res.get(i).id;
      }
      return a;
    }
  
     private class Pair{
         int id;
         int rating;
       
         public Pair(int id, int rating) {
              this.id = id;
              this.rating = rating;
         }
     }
```

## 二、[2. 合并两个有序链表](https://u.geekbang.org/playground/exam/1020?question=8572)

### 解法一：

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
      if (l1==null) return l2;
      if (l2==null) return l1;
      ListNode node = null;
      if (l1.val>l2.val) {
        node = new ListNode(l2.val);
        node.next = mergeTwoLists(l1, l2.next);
      }else {
        node = new ListNode(l1.val);
        node.next = mergeTwoLists(l1.next, l2);
      }
      return node;
    }
}
```

## 三、[视野总和](https://u.geekbang.org/playground/exam/1020?question=8573)

### 解法一：

```
    public int fieldSum(int[] v) {
      Deque<Integer> deque = new LinkedList<>();
      int res=0;
      for (int i=0; i<=v.length; i++) {
        int t = Integer.MAX_VALUE;
        if (i<v.length) t = v[i];
        while (!deque.isEmpty() && v[deque.peek()]<=t) {
           int pre = deque.pop();
           res += i-pre-1;
        }
        deque.push(i);
      }
      return res;
    }
```

## 四、[数据流查询](https://u.geekbang.org/playground/exam/1020?question=8574)

### 解法一：使用Map

````
    public int[] findTopKQuery(int[][] orders, int k) {
      int m = orders.length;
      Map<Integer, List<Integer>> tMap = new HashMap<>();
      Map<Integer, Integer> idMap = new HashMap<>();
      for (int i=0; i<m; i++) {
         int id = orders[i][0];
         int t = orders[i][1];
         tMap.putIfAbsent(t, new ArrayList<>());
         tMap.get(t).add(id);
         idMap.put(id, orders[i][2]);
      }
      List<Integer> result = new ArrayList<>();
      for (int diff=0;diff<k;diff++) {
        int minT = Integer.MAX_VALUE;
        for (Map.Entry<Integer, List<Integer>> entry: tMap.entrySet()) {
              minT = Math.min(minT, entry.getKey());
        }
        List<Integer> list = tMap.get(minT);
        Collections.sort(list, Integer::compareTo);
        result.addAll(list);
        tMap.remove(minT);
        for (Integer id: list) {
          int temT = minT + idMap.get(id);
          tMap.putIfAbsent(temT, new ArrayList<>());
          tMap.get(temT).add(id);
        }
      }
      int[] a = new int[k];
      for (int j=0; j<k; j++) {
        a[j]=result.get(j);
      }
      return a;
    }
````

### 解法二：归并

```
    public int[] findTopKQuery(int[][] orders, int k) {
      int m = orders.length;
      int[] ta = new int[m];
      for (int j=0; j<m; j++) {
        ta[j] = orders[j][1];
      }
      int[] res = new int[k];
      for (int i=0; i<k; i++) {
        int minT = Integer.MAX_VALUE;
        int n=0;
        for (int j=0;j<ta.length;j++) {
          if (ta[j]<minT) {
            minT = ta[j];
            n=j;
          }
        }
        res[i]=orders[n][0];
        ta[n]+=orders[n][2];
      }
      return res;
    }
```

## 五、[每日在线用户量](https://u.geekbang.org/playground/exam/1020?question=8575)

### 解法一：队列

```
    public int[] dailyTemperatures(int[] T) {
      int n = T.length;
      int[] res = new int[n];
      Deque<Integer> deque = new LinkedList<>();
      for (int i=0; i<n; i++) {
        while (!deque.isEmpty() && T[deque.peek()]<T[i]) {
          int j = deque.pop();
          res[j] = i-j;
        }
        deque.push(i);
      }
      return res;
    }
```


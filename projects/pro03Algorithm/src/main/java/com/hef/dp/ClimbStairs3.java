package com.hef.dp;

/**
 * 爬楼梯： 一次可以爬 1、2、3， 并且相邻步伐不能相同
 * @Date 2021/9/15
 * @Author lifei
 */
public class ClimbStairs3 {

    /**
     2. 每次能走1，2，3步， 但是相邻的两步不能相同， 如何？
     问题2解题

     1. 重复性子问题
     n = 0, {0}
     n = 1 , {1}
     n = 2 , {2}
     n = 3, { 12, 21, 3}

     n = 4, {121, 13, 31}
     n =5,
     走1步 ，剩4阶，f(4)中排除第1步为1的，将1加在前面
     走2步 ，剩3阶，f(3)排除第1步为2的，将2加在前面
     走3步， 剩2阶，f(2)排除第1步为3的，将3加在前面
     {131,212,23,32}
     n = 6
     走1步 ，剩5阶，f(5)中排除第1步为1的，将1加在前面
     走2步 ，剩4阶，f(4)中排除第1步为2的，将2加在前面
     走3步， 剩3阶，f(3)中排除第1步为3的，将3加在前面
     {1212,123,132, 2121,213,231,312, 321 }
     n = 7
     {12121, 1213, 1231, 1312, 1321, 2131, 232, 3121, 313}
     n = 8
     4 + 5 + 3 = 12
     n = 9
     8 + 7 + 6 = 21 ，不列举了，好累 >...<
     n:
     走1步 ，剩n-1阶， f(n-1)中排除第1步为1的，将1加在前面
     走2步 ，剩n-2阶， f(n-2)中排除第1步为2的，将2加在前面
     走3步 ，剩n-3阶， f(n-3)中排除第1步为3的，将3加在前面
     2. 状态数组
     如何在n阶时， 把第1步的状态(1,2,3)记录下来？
     dp[n阶] [ 第一步状态] = 方法数
     3. 递推方程，DP方程
     dp[n][1] = dp[n-1][2] + dp[n-1][3]
     dp[n][2] = dp[n-2][1] + dp[n-2][3]
     dp[n][3] = dp[n-3][1] + dp[n-3][2]
     return: dp[n][1]+ dp[n][2] + dp[n][3]
     4.代码
     class Solution
     {
     public:
     int climbStairs(int n)
     {
     // 3+1 :{1,2,3} 3个状态
     // dp[n阶] [ 第一步状态 ] = 方法数
     // n+4 仅为保证 n = 0 时的合法性
     vector<vector<int>> dp(n+4, vector<int>(3 + 1, 0));
     dp[1][1] = 1; // {1}
     dp[2][2] = 1; // {2}
     dp[3][1] = 1; // { 12, 21, 3}
     dp[3][2] = 1; //
     dp[3][3] = 1; //
     for(int i = 4; i <=n; ++i)
     {
     if(i - 1 >=0)
     dp[i][1] = dp[i-1][2] + dp[i-1][3];
     if(i - 2 >=0)
     dp[i][2] = dp[i-2][1] + dp[i-2][3];
     if(i - 3 >=0)
     dp[i][3] = dp[i-3][1] + dp[i-3][2];
     }
     return dp[n][1]+ dp[n][2] + dp[n][3];
     }
     };

//     test : 0-8
     output:
     0
     1
     1
     3
     3
     4
     8
     9
     12
     */
    public static void main(String[] args) {
        int n = 9;
        for (int i=0; i<=n; i++) {
            int res = solve(i);
            System.out.print(i + ": " + res + ", ");
        }
        System.out.println();
    }

    /**
     * 走n阶台阶： 一次可以走 1、2、3 步，相邻步数不能相同
     * @param n
     * @return
     */
    public static int solve(int n) {
        if (n<=2) return n;
        if (n==3) return 2;
        // 走n阶台阶，第一步可以走1、2、3
        int[][] dp = new int[n+1][4];
        // n=1 时，第一步只能走 1步
        dp[1][1] = 1;
        // n=2 时， 第一步只能走 1步
        dp[2][2] = 1;
        // n=3 时，第一步可以走 1 步、2步
        dp[3][1] = 1;
        dp[3][2] = 1;
        dp[3][3] = 1;

        for (int i=4; i<=n; i++) {
            // 走i步：第一步走1步=第二步走2步+第二步走3步
            dp[i][1] = dp[i-1][2] + dp[i-1][3];
            // 走i步：第一步走2步=第二步走1步+第二步走3步
            dp[i][2] = dp[i-2][1] + dp[i-2][3];
            // 走i步：第一步走3步=第二步走1步+第二步走2步
            dp[i][3] = dp[i-3][1] + dp[i-3][2];
        }
        // 上n阶台阶 = 第一步走1步 + 第一步走2步 + 第一步走3步
        return dp[n][1] + dp[n][2] + dp[n][3];
    }
}
